/* ------------------------------------------
 *
 *                    PIN
 * 
 * ------------------------------------------
 */

class Pin {

  /*  Description:
   *    The standard Pin class. Generated and used to represent every pin on the map embed. Each pin has member functions that
   *    handle its listener generation, infobox generation & handling, and hiding from the map.
   *
   *  Expects:
   *    - pin =>
   *        {
   *          map    : 'MAP_EMBED',
   *          mapDOM : 'MAP_DOM_NODE',
   *          marker : 'MAP_MARKER',
   *          name   : 'PIN_NAME',
   *          latLng : 'PIN_LATLNG'
   *        }
   */

  constructor(pin) {

    this.map            = pin.map;      // A map embed linked to the Maps API.
    this.mapDOM         = pin.mapDOM;   // The DOM node that holds the associated map embed.
    this.marker         = pin.marker;   // Marker generated by the Maps API.
    this.name           = pin.name;     // Pin's name.
    this.latLng         = pin.latLng;   // latLng generated by the Maps API. Used to access the latitude & longitude.
    this.clickListener  = null;         // Click listener. Generated when calling member function generateListener().
    this.infoBox        = null;         // Infobox. Generated when calling member function showInfo().
    this.description    = null;         // Optional text description.

    this.generateListener = this.generateListener.bind(this);
    this.showInfo         = this.showInfo.bind(this);
    this._handleInfoBox   = this._handleInfoBox.bind(this);
    this._handleTrash     = this._handleTrash.bind(this);
    this.hide             = this.hide.bind(this);

  }

  generateListener() {

    const mapEvent     = window.mapEvent;
    this.clickListener = mapEvent.addListenerOnce(this.marker, 'click', this.showInfo);
    
  }

  showInfo(event) {

    /*  Description:
     *    Calls HTMLGen to generate the current pin's infobox. Then handles logical interactions with member function _handleInfoBox().
     *
     *  Expects:
     *    - event => Event parameter passed by the pin's click listener.
     */

    const mapEvent      = window.mapEvent;
    const mapInterface  = window.mapInterface;
    const HTMLGen       = window.HTMLGen;

    let context = {

      name   : this.name,
      latLng : this.latLng

    }

    if (this.description)
      context.description = this.description;

    this.map.panTo(event.latLng);
    this.infoBox = mapInterface.generateInfoBox(event.latLng, HTMLGen.PinInfo(context));

    mapEvent.addListenerOnce(this.infoBox, 'domready', () => {

      this._handleInfoBox();

    });

  }

  _handleInfoBox() {

    const mapEvent = window.mapEvent;

    let infoBoxDOM              = this.mapDOM.querySelector(`.pin-infobox-container[data-latlng="${this.latLng}"]`);
    let infoBox_buttonContainer = infoBoxDOM.querySelector('.trash-button-container');
    let infoBox_trashButton     = infoBox_buttonContainer.querySelector('button.trash-button');

    mapEvent.addDomListenerOnce(infoBox_trashButton, 'click', this._handleTrash);

    mapEvent.addListenerOnce(this.infoBox, 'closeclick', () => {

      this.infoBox.close();
      this.generateListener();

    });

  }

  _handleTrash() {

    const mapEvent     = window.mapEvent;
    const mapInterface = window.mapInterface;
    const HTMLGen      = window.HTMLGen;

    let infoBoxDOM              = this.mapDOM.querySelector(`.pin-infobox-container[data-latlng="${this.latLng}"]`);
    let infoBox_buttonContainer = infoBoxDOM.querySelector('.trash-button-container');
    let infoBox_trashButton     = infoBox_buttonContainer.querySelector('button.trash-button');

    let confirmText;
    let checkButton;
    let xButton;

    // Hide the trash button and prompt the user for confirmation.
    infoBox_buttonContainer.removeChild(infoBox_trashButton);
    infoBox_buttonContainer.insertAdjacentHTML('afterbegin', HTMLGen.ConfirmText());

    // Query select for listener interactions.
    confirmText = infoBox_buttonContainer.querySelector('.are-you-sure');
    checkButton = infoBox_buttonContainer.querySelector('.fas.fa-check-circle');
    xButton     = infoBox_buttonContainer.querySelector('.fas.fa-times-circle');

    // Confirm deletion.
    mapEvent.addDomListenerOnce(checkButton,'click', () => {

      mapInterface.removePin(this);

    });

    // Cancel deletion.
    mapEvent.addDomListenerOnce(xButton, 'click', () => {

      infoBox_buttonContainer.removeChild(confirmText);
      infoBox_buttonContainer.insertAdjacentHTML('afterbegin', HTMLGen.TrashButton());

      // Reset the infobox by clearing listeners and calling the handler again.
      mapEvent.clearInstanceListeners(this.infoBox);

      this._handleInfoBox();

    });

  }

  hide() {

    this.marker.setMap(null);

    if (this.clickListener)  this.clickListener.remove();
    if (this.infoBox)        this.infoBox.close();

  }

}

/* ------------------------------------------
 *
 *               MAP INTERFACE
 * 
 * ------------------------------------------
 */

class MapInterface {

  /*  Description:
   *    Used to handle all interactions directly associated with the map embed. e.g. Generating new pins, removing pins,
   *    loading / clearing map, synchronising the pin list with React components, etc.
   *
   *  Expects:
   *    - mapEmbed   => A map embed linked with the Maps API.
   *    - mapDOMNode => The DOM node that holds the associated map embed.
   */

  constructor(mapEmbed, mapDOMNode) {

    this.mapEmbed   = mapEmbed;
    this.mapDOMNode = mapDOMNode;
    
    this.pinList = [];

    this.generateNewPin  = this.generateNewPin.bind(this);
    this.generateInfoBox = this.generateInfoBox.bind(this);
    this.clearMap        = this.clearMap.bind(this);
    this.loadMap         = this.loadMap.bind(this);
    this.addPin          = this.addPin.bind(this);
    this.removePin       = this.removePin.bind(this);

    // null until the React Map component passes the function.
    this.updatePlaces = null;

  }

  generateNewPin(event) {

    /*  Description:
     *    Calls HTMLGen to generate a new pin form. Prepares a generic pin object to be passed to member function
     *    _handleNewPinForm() for handling logical interactions and constructing a new Pin instance.
     * 
     *  Expects:
     *    - event => Event parameter passed by the map's click listener.
     */

    const google   = window.google;
    const mapEvent = window.mapEvent;
    const HTMLGen  = window.HTMLGen;

    let newInfoForm = this.generateInfoBox(event.latLng, HTMLGen.NewPinForm());

    let newMarker = new google.maps.Marker({

      position : event.latLng,
      map      : this.mapEmbed

    });

    mapEvent.addListenerOnce(newInfoForm, 'domready', () => {

      let newPin = {

        marker  : newMarker,
        infoBox : newInfoForm,
        latLng  : event.latLng

      }

      this._handleNewPinForm(newPin);

    });

  }

  generateInfoBox(latLng, html) {

    /*  Description:
     *    Calls the Maps API to generate an infobox on the map embed at the given latLng and with the given HTML content.
     *
     *  Expects:
     *    - latLng => An API latLng object denoting the coordinates to generate the infobox.
     *    - html   => The HTML content to display within the infobox.
     */

    const google = window.google;

    let offset  = new google.maps.Size(0, -35, 'pixel', 'pixel');
    let infoBox = new google.maps.InfoWindow();

    infoBox.setPosition(latLng);
    infoBox.setContent(html);
    infoBox.setOptions({ pixelOffset: offset });
    infoBox.open(this.mapEmbed);

    return infoBox;

  }

  _handleNewPinForm(newPin) {

    /*  Description:
     *    Handles logical interactions for a new pin form. Consolidates user input and pin information to generate a new Pin instance.
     *
     *  Expects:
     *    - newPin =>
     *        {
     *          marker  : 'MAP_MARKER',
     *          infoBox : 'NEW_PIN_INFOFORM',
     *          latLng  : 'NEW_PIN_LATLNG'
     *        }
     */

    const mapEvent = window.mapEvent;

    let infoForm              = this.mapDOMNode.querySelector('.pin-infoform-container');
    let infoForm_nameField    = infoForm.querySelector('input.pin-infoform-name');
    let infoForm_descField    = infoForm.querySelector('textarea.pin-infoform-description');
    let infoForm_saveButton   = infoForm.querySelector('button[name="save"]');
    let infoForm_cancelButton = infoForm.querySelector('button[name="cancel"]');

    let formattedPinName;
    let newPinName;

    // Save event
    mapEvent.addDomListener(infoForm_saveButton, 'click', () => {

      formattedPinName  = (infoForm_nameField.value ? infoForm_nameField.value.trim()       : null);
      newPinName        = (formattedPinName         ? formattedPinName.replace(/\s+/g, ' ') : null);

      if (newPinName) {

        newPin.infoBox.close();

        let pin = new Pin({

          map    : this.mapEmbed,
          mapDOM : this.mapDOMNode,
          marker : newPin.marker,
          name   : newPinName,
          latLng : newPin.latLng

        });

        if (infoForm_descField.value)
          pin.description = infoForm_descField.value;

        pin.generateListener();

        this.addPin(pin);

        mapEvent.addListenerOnce(this.mapEmbed, 'click', this.generateNewPin);

      } else {

        alert('You must enter a name for a new pin.');

      }

    });

    // Exit event
    mapEvent.addDomListener(infoForm_cancelButton, 'click', () => {

      newPin.marker.setMap(null);
      newPin.infoBox.close();

      // Re-generate map listener.
      mapEvent.addListenerOnce(this.mapEmbed, 'click', this.generateNewPin);

    });

    // Exit event
    mapEvent.addListener(newPin.infoBox, 'closeclick', () => {

      newPin.marker.setMap(null);
      newPin.infoBox.close();

      // Re-generate map listener.
      mapEvent.addListenerOnce(this.mapEmbed, 'click', this.generateNewPin);

    });

  }

  clearMap() {

    /*  Description:
     *    Hide all currently displayed pins and clear the map's pin list, then update the React places list.
     */

    // **FIX: Clearing map does not close a new pin form, if one is rendered.

    this.pinList.forEach((pin) => {

      pin.hide();

    });

    this.pinList = [];
    this.updatePlaces(this.pinList);

  }

  loadMap(newPins) {

    /*  Description:
     *    Render a new map with the given pin list, then update the React places list.
     *
     *  Expects:
     *    - newPins =>
     *        [
     *          {
     *            name        : 'PIN_NAME',
     *            description : 'PIN_DESC',
     *            lat         : 'PIN_LAT',
     *            lng         : 'PIN_LNG'
     *          },
     *          . . .
     *        ]
     */

    const google = window.google;

    newPins.forEach((newPin) => {

      let coords = { lat: parseFloat(newPin.lat), lng: parseFloat(newPin.lng) };

      let newLatLng = new google.maps.LatLng(coords);

      let marker = new google.maps.Marker({

        position : newLatLng,
        map      : this.mapEmbed

      });

      let pin = new Pin({

        map    : this.mapEmbed,
        mapDOM : this.mapDOMNode,
        marker : marker,
        name   : newPin.name,
        latLng : newLatLng

      });

      if (newPin.description)
        pin.description = newPin.description;

      pin.generateListener();

      this.pinList.push(pin);

    });

    this.updatePlaces(this.pinList);

  }

  addPin(pin) {

    /*  Expects:
     *    - pin => A Pin instance.
     */

    this.pinList.push(pin);
    this.updatePlaces(this.pinList);

  }

  removePin(pin) {

    /*  Expects:
     *    - pin => A Pin instance.
     */

    pin.hide();
    this.pinList.splice(this.pinList.indexOf(pin), 1);
    this.updatePlaces(this.pinList);

  }

}

/* ------------------------------------------
 *
 *                  EXPORT
 * 
 * ------------------------------------------
 */

export default MapInterface;
